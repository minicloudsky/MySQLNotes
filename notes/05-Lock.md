## MySQL 锁

MySQL 锁设计初衷为了控制并发问题，出现并发访问时候合理控制资源的访问规则。

锁类型: `全局锁、表级锁和行锁`

### **全局锁**

全局锁对整个库加锁

Flush tables with read lock (FTWRL) 加全局锁，让整个库处于只读,之后其他线程语句会被阻塞: 数据更新语句（增删改）、数据定义语句(建表，修改表结构)等和更新类事务的提交语句。

全局锁用于做全库逻辑备份，把整个库每个表都 select 出来存成文本。

通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整库做数据备份，在备份过程中整个库处于只读状态。

整个库备份很危险:

- 在主库备份，备份期间都不能执行更新，业务基本停摆

- 在从库备份，备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

  

假如你维护 "极客时间"的购买系统，关注用户账户余额表和用户课程表

现在发起一个逻辑备份，有个用户买了一门课程，业务逻辑里面要扣掉他的余额，然后往已购课程里面加入一门课。

如果时间顺序上是先备份账户余额表(u_account),然后用户购买，然后备份用户课程表(u_course)

![](../imgs/backup-status.png)

这个备份结果里，用户 A 的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户 A 就发现，自己赚了,如果备份顺序反过来，会出现用户课程没添加，但是余额已经扣了。

不加锁的话，备份系统备份得到的库不是一个逻辑时间点，视图逻辑不一致。

在可重复读隔离级别下开启一个事务，可以拿到一致性视图。

mysql官方逻辑备份工具是 `mysqldump`，当 `mysqldump` 使用参数 `-single-transaction` 时候，导数据之前会启动一个事务，来确保拿到一致性视图，由于 MVCC 的支持，这个过程中数据可以正常更新。

一致性读的前提是数据库引擎要支持这个隔离级别，对于 MyISAM 这种不支持事务的引擎，在备份过程中有更新，总是能取到最新的数据，那么就破坏了备份的一致性，这时候就需要 FTWRL 命令。

`-single-transaction` 方法只适用于所有的表使用事务引擎的库，如果有的表使用了不支持事务的库引擎，那么备份就只能通过 FTWRL 方法，这也是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因。

全库只读，readonly 也可以让全库进入只读状态，不使用  `set global readonly=ture` 的原因:

- 在有些系统中，readonly 的值会用来做其他逻辑，比如用来判断一个库是主库还是备库，修改 global 变量影响面更大，不建议使用。
- 异常处理机制有差异。执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态，而将整个库设置为  readonly 之后，如果客户端发生异常，数据库会一直保持 readonly 状态，导致整个库长时间处于不可写状态，风险较高。

业务的更新不只是增删改数据(DML),还可以是加字段等修改表结构的操作(DDL),无论哪种方法，一个库被全局锁上之后，你要对任何一个表做加字段操作，都是会被锁住的，即使没被全局锁住，也会碰到`表级锁`。

### 表级锁

MySQL 里面表级别锁有两种: 表锁，元数据锁(meta data lock, MDL)

表锁语法: `lock tables ... read/write` 与 FTWRL 类似，可以用 `unlock tables` 主动释放锁，也可以在客户端断开时候自动释放，`lock tables` 语法除了会限制别的线程读写以外，也限制了本线程接下来的操作对象。

举个例子，如果在某个线程 A 中执行 `lock tables t1 read,t2 write;` 语句，则其他线程写 t1, 读写 t2 的语句都会被阻塞。同时，线程 A 在执行 `unlock tables` 之前，也只能执行读 t1、读写 t2 的操作，连写 t1 都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式，对于 InnoDB 这种支持行锁的引擎，一般不使用  `lock tables`  命令来控制并发。毕竟锁住整个表的影响面还是太大。

另一类的锁是 MDL (metadata lock) MDL 不需要显式调用，在访问一个表的时候会被自动家桑能啊，MDL 的作用是，保证读写的正确性，你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

`MySQL 5.5 版本引入了 MDL`,当对一个表做增删改查桑哦吼，加 MDL 读锁，要对表结构变更操作时候，加 MDL 写锁。

- 读写不互斥，你可以有多个线程同时对一张表增删改查
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才可以开始执行。

虽然 MDL 锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。

你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。(实验环境为 MySQL 5.6)

![](../imgs/metadata-lock.jpg)

session A 先启动，这时候会对表  t 加一个 MDL 读锁，由于 session B 需要的也是 MDL 读锁，因此可以正常执行。

之后 sessionC 会被 blocked ，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。

如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

如何安全的给小表加字段？

首先我们要解决长事务，事务部提交，就会一直占着 MDL 锁，在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务，如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL,或者 kill 掉这个长事务。

考虑以下场景，如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，该怎么做？

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 `alter  table` 语句里面设定等待事件，如果在这个指定的等待事件里面能拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发恩怨或者 DBA 再通过重试命令重复这个过程。

MariaDB 合并了 AliSQL 的这个功能，这两个开源分支目前都支持 DDL `NOWAIT/WAIT n` 这个语法。

```sql
alter table tbl_name NOWAIT add column xxx
alter table tbl_name WAIT N add column xxx
```

 全局锁主要用在逻辑备份过程中，对于全部是 InnoDB 引擎的库，使用 `-single-transaction` 参数对应用会更友好。

表锁一般在数据库引擎不支持行锁的时候才会被用到，如果你发现应用程序里面有 `lock tables` 这样的语句，你需要追查下，比较可能的情况是:

- 要么是你的系统还在用 MyISAM 这样不支持事务的引擎，那要安排升级还引擎；
- 要么是引擎升级了，代码没升级，把 `lock tables` 和 `unlock tables` 改成  `begin` 和 `commit`,问题就可以解决。

MDL 会知道事务提交才释放，在做表结构变更时候，一定要小心不要导致锁住线上查询和更新。

### Q: 备份一般都会在备库上执行，用 `-single-transcation` 方法做逻辑备份过程中，如果主库上的一个小表做了一个 DDL,比如给一个表上加了一列，此时从备库上会看到什么现象呢？

A: 假设这个 DDL是针对表 t1 的，这里我把备份过程中几个关键的语句列出来:

```sql

Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/* other tables */
Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */
```

- 在备份开始的时候，为了确保 RR(可重复读)隔离级别，再设置一次 RR 隔离级别(Q1);
- 启动事务，这里用 `with consistent snapshot` 确保这个语句执行完就可以得到一个一致性视图(Q2)
- `show create table` 是为了拿到表结构(Q4),然后正式导数据(Q5),回滚到sp，在这里的作用是释放 t1 的 MDL锁(Q6)（这部分超纲）.  

DDL 从主库传过来的时间按照效果不同，打了四个时刻，题目设定为小表，我们假定到达后，儒生哦开始执行，则很快能够执行完成。

参考答案:

1. 如果在 Q4 语句执行之前到达，现象: 没有影响，备份拿到的是 DDL 后的表结构。
2. 儒生哦在 "时刻2" 到达，则表结构被改过，Q5 执行的时候，报 `Table definition has changed,please retry transaction`,现象: `mysqldump` 终止；
3. 如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：`主从延迟，直到 Q6 执行完成`。
4. 从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：`没有影响，备份拿到的是 DDL 前的表结构`。

### 行锁: 如何减少行锁对性能的影响

MySQL 的行锁是在引擎层由各个引擎自己实现的，但是并不是所有引擎都支持行锁，比如 MyISAM 引擎就不支持行锁，不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，会影响到业务并发度，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

下面介绍下行锁以及如何通过减少锁冲突来提升业务并发度。

行锁是针对数据表中行记录的锁，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

#### 两阶段锁

在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。

![](../imgs/two-phrase-lock.jpg)

这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放，实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。

事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。也就是说，`在 InnoDb 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。`

如果你的事务中需要锁多行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票，简化下这个业务需要涉及到以下操作:

1. 从顾客 A 账户余额中扣除电影票价；

2. 给影院 B 的账户余额增加这张电影票价；

3. 记录一条交易日志。

   

也就是说，要完成这个交易，需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务里。如何安排顺序呢？

如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部门就是语句 2 了，因为他们要更新同一个影院账户的余额，需要修改同一行数据。

根据两阶段锁协议，无论如何安排语句顺序，所有的操作需要的行锁都是在事务提交的时候释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度，这样影院余额这一行的行锁在一个事务中不会停留很长时间。

如果这个影院做活动，可以低价预售一年内的所有电影票，而且这个活动只做一天，于是在活动时间开始的时候，你的 MySQL 就挂了。你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到100个事务，这是为何？

这里就要说到死锁和死锁检测了。

### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁，这里用行锁举个例子。

![](../imgs/row-lock.jpg)

此时，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1的行锁。事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略:

- 一种策略，直接进入等待，直到超时。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置。
- 另一种策略是，发起死锁检测发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 `on`,表示开启这个逻辑。

在 InnoDB 中，`innodb_lock_wait_timeout` 的默认值是 50s，意味着如果采用第一个策略，`当出现死锁以后，第一个被锁住的线程要过50s 才会超过退出。然后其他线程才有可能继续执行。对于在线服务来说，这个等待事件往往是无法接受的`。

但是又不可能直接把这个时间设置成很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢，所以，`超时时间设置太短的话，会出现很多误伤`。

正常情况下采用`主动死锁检测`，而且 `innodb_deadlock_detect` 的默认值本身就是 on,主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

想象下L 每当一个事务被锁，就要看看它锁依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

那如果是`所有的事务都要更新同一行的场景呢？`

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度为 O(n) 的操作，假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是100万量级的，虽然最终检测的结果是没有死锁，但是这要消耗大量的 CPU 资源，因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。

如何解决`由于热点行更新导致的性能问题`？问题症结在于，`死锁检测要耗费大量的 CPU资源。`

- 头疼医头: 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题，这是业务无损的，而关掉死锁检测意味着肯呢个会出现大量超时，这是业务有损的。
- 控制并发度。根据上面分析你会发现，如果并发能够控制住，比如同一行同时最多只有 10个线程在更新，那么死锁检测成本很低，就不会出现这个问题，一个直接想法是在客户端做并发控制，但是你会发出西安这个方法不太行，因为客户端很多，我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。因此，这个并发控制要做在服务端，如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，`对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。`

##### 如果团队暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？

考虑通过将这一行改成逻辑上的多行来减少锁冲突，以影院为例，可以考虑放在多条记录上，比如10条记录，影院的账户总额等于这10个记录的值的总和，这样每次要给影院账户加金额时候，随机选其中一条来加，这样每次冲突概率编程原来的 1/10,可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。这个方案看上去无损，但其实这类方案需要根据业务逻辑做详细设计，如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。但是，调整语句顺序并不能完全避免死锁。减少死锁的主要方向，就是控制访问相同资源的并发事务量。

`InnoDB 行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。`

### Q: 如果你要删除一个表的前 10000 行数据，有以下三种方法可以做到:

- 第一种，直接执行 `delete from T limit 10000;`
- 第二种，在一个连接中循环执行 20次 `delete from T limit 500;`
- 第三种，在 20 个连接中同时执行 `delete from T limit 500;`

你会选择哪一种方法呢？为什么呢？

A：第二种比较友好

第一种方式，单个语句占用时间长，锁的时间也比较长，而且大事务还会导致主从延迟。

第三种，会人为造成锁冲突。

