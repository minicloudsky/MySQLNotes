## 02 - Mysql 更新语句执行过程

#### ddl 和更新语句

```sql
create table T(ID int primary key, c int);
update T set c=c+1 where ID=2;
```

![](../imgs/1.png)

执行前使用`连接器`连接数据库，表更新会导致与该表有关的`查询缓存`都失效，因此上面的 update sql 会把表 T 上的所有缓存结果都清空，因此查询缓存效率比较低，一般不建议使用查询缓存。

`分析器`通过词法和语法解析知道这是更新语句，`优化器`决定要使用 ID 这个索引，`执行器`负责具体执行，找到该行后更新。

更新流程涉及到 两个日志模块:  `redo log (重做日志)` 和 `binlog （归档日志）`

###  redo log

`《孔乙己》里面，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。`

`如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。`

`如果有人要赊账或者还账的话，掌柜一般有两种做法：`

- `一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；`

- `另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。`

`在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。`

在 MYSQL 中，如果每次 更新操作都需要写入磁盘，磁盘找到对应记录，再更新，整个过程 IO成本，查找成本很高。

MySQL WAL (Write-Ahead Logging) 技术,先写日志，再写磁盘，也就是先写粉板，等不忙时候再写账本，即当有记录需要更新，InnoDB 引擎先把记录写到 `redo log` , 并更新内存，此时更新就算完成。InnoDB 引擎在适当时候将该操作记录更新到磁盘，这个更新往往在系统空闲时候做。

`如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。`

InnoDB 的  `redo log` 为固定大小，可配置为一组 4个文件，每个文件大小 1GB，那么这个“粉板” 一共可记录 4GB 的操作，从头开始写，写到末尾又到开头循环写

![](../imgs/redolog.png)

`write pos` 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。`checkpoint` 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。`write pos` 和 `checkpoint` 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 `write pos` 追上 `checkpoint`，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 `checkpoint` 推进一下。有了 `redo log`，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 `crash-safe`。



