## MySQL 查询执行过程

### Mysql 基本架构

![img](../imgs/1.png)

MySQL 可以分为 Server 层和存储引擎层两部分。

Server 层包括`连接器`、`查询缓存`、`分析器`、`优化器`、`执行器`等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分

### 连接器

连接器负责 和客户端建立连接，获取权限，维持和管理连接，连接mysql:

```bash
mysql -h ip -u user -P port -p
```

- 密码不正确会收到  "Access denied for user" error

- 用户密码认证通过，连接器查询该用户拥有的权限，之后，这个连接器里面的权限判断逻辑，都依赖于此时读到的权限，因此连接建立后，即使管理员对该用户权限修改，也不会影响已经建立连接的权限，修改完权限只有下次创建连接才生效。

- `show processlist` 查看连接，`command` 为 `Sleep` 的表示空闲连接

- `wait_timeout` 控制连接超时时间，默认 8 h

- 长连接: 客户端持续有请求，一直使用同一个连接，弊端：MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了

- 短连接: 每次执行完很少的查询就断开连接

- 解决 mysql 内存占用大问题

  1. 定期断开长连接，使用一段时间，或者程序里判断执行过一个占用内存大的查询后，断开连接，之后重新连接
  2. mysql 6.7或更高版本，每次执行比较大操作后执行  `mysql_reset_connection` 重新初始化连接资源，该过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时候的状态

  

### 查询缓存

 - mysql 拿到查询请求，先到查询缓存查询，看之前是否执行过该 sql，之前查询过的语句和结果会以 key-value 形式缓存在内存中，key 为查询 sql，value 为查询结果，如果在缓存中查到这个额sql对应的key就直接返回给客户端，如果不存在就继续执行，执行结果会写入查询缓存
  
 - ##### 查询缓存利大于弊
  
 - 查询缓存失效频繁，只要对一个表进行更新，该表所有查询缓存会清空，对更新压力大的库来说，查询缓存命中率很低，静态表（不经常更新的表）适合使用查询缓存。

 - 按需使用: 将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定,像下面语句:

 - ```bash
   select SQL_CACHE * from T where ID=10;
   ```
 - Mysql 8.0 [移除了查询缓存](https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/)功能,也就是 8.0开始没有这个功能了 


### 分析器

如果未命中查询缓存，就开始执行语句，mysql 会对 sql 语句做解析，进行词法分析识别出每个字符，然后做语法分析，根据语法规则，判断用户输入的mysql是否符合 MySQL 语法，语法不正确会报错。

### 优化器

优化器是在表里面有多个索引时候，决定用哪个索引，或者在一个语句里面有多表 join 时候，决定各个表的连接顺序，例如:

```bash
mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。

- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。
- 优化器阶段完成后，语句执行方案就已经确定，进入执行器

### 执行器

- `执行器执行 sql 语句，开始执行时候会判断权限`，没权限会返回没有权限的错误(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)

- 有权限会打开表继续执行，打开表适合根据表的引擎定义，使用该引擎提供的接口

- 例如以下sql: 

- ```sql
  select * from T where ID=10;
  ```

- 执行器调用 InnoDB 引擎取第一行，判断 ID 值是不是 10，不是跳过，是的话将这行存进 结果集

- 调用引擎取下一行，重复相同判断逻辑，直到取到表最后一行。

- 慢查询日志 `rows_examined` 字段记录该语句在执行过程中扫描了多少行，该值是在执行器每次获取数据行时候累加的

- 在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的



